<!DOCTYPE html>
<html>

<head>
    <title>Our Changing City Map</title>
    <meta charset="utf-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.css" />
    <link rel="stylesheet" href="css/mapyears.css" />

    <style>
        .hexbin-hexagon {
            stroke: #000;
            stroke-width: 1px;
        }
    </style>

</head>

<body>
    <div id="map"></div>
    <div id="layers"></div>

    <script src="js/assaultdata.js" type="text/javascript"></script>
    <script type="text/javascript" src="lib/jquery.min.js"></script>
    <script type="text/javascript" src="lib/d3.min.js"></script>
    <script src='https://api.tiles.mapbox.com/mapbox.js/v2.1.9/mapbox.js'></script>
    <script src="lib/hexbin.js" type="text/javascript"></script>
    <script src="lib/leaflet-d3.min.js" type="text/javascript"></script>
    <script src="lib/simple_statistics.js"></script>


    <script>
        L.HexbinLayer = L.Class.extend({
            includes: L.Mixin.Events,
            initialize: function (rawData, options) {
                this.levels = {};
                this.layout = d3.hexbin().radius(10);
                this.rscale = d3.scale.sqrt().range([0, 10]).clamp(false);
                this.rwData = rawData;
                this.config = options;
            },
            project: function (x) {
                var point = this.map.latLngToLayerPoint([x[1], x[0]]);
                return [point.x, point.y];
            },
            getBounds: function (d) {
                var b = d3.geo.bounds(d)
                return L.bounds(this.project([b[0][0], b[1][1]]), this.project([b[1][0], b[0][1]]));
            },
            update: function () {
                var pad = 100,
                    xy = this.getBounds(this.rwData),
                    zoom = this.map.getZoom();

                this.container
                    .attr("width", xy.getSize().x + (2 * pad))
                    .attr("height", xy.getSize().y + (2 * pad))
                    .style("margin-left", (xy.min.x - pad) + "px")
                    .style("margin-top", (xy.min.y - pad) + "px");

                if (!(zoom in this.levels)) {
                    this.levels[zoom] = this.container.append("g").attr("class", "zoom-" + zoom);
                    this.genHexagons(this.levels[zoom]);
                    this.levels[zoom].attr("transform", "translate(" + -(xy.min.x - pad) + "," + -(xy.min.y - pad) + ")");
                }
                if (this.curLevel) {
                    this.curLevel.style("display", "none");
                }
                this.curLevel = this.levels[zoom];
                this.curLevel.style("display", "inline");
            },
            genHexagons: function (container) {
                var data = this.rwData.features.map(function (d) {
                    var coords = this.project(d.geometry.coordinates)
                    return [coords[0], coords[1], d.properties];
                }, this);

                var bins = this.layout(data);
                var hexagons = container.selectAll(".hexagon").data(bins);

                var counts = [];
                bins.map(function (elem) {
                    counts.push(elem.length)
                });
                this.rscale.domain([0, (ss.mean(counts) + (ss.standard_deviation(counts) * 10))]);

                var path = hexagons.enter().append("path").attr("class", "hexagon");
                this.config.style.call(this, path);

                that = this;
                hexagons
                    .attr("d", function (d) {
                        return that.layout.hexagon(that.rscale(d.length));
                    })
                    .attr("transform", function (d) {
                        return "translate(" + d.x + "," + d.y + ")";
                    });
            },
            addTo: function (map) {
                map.addLayer(this);
                return this;
            },
            onAdd: function (map) {
                this.map = map;
                var overlayPane = this.map.getPanes().overlayPane;

                if (!this.container || overlayPane.empty) {
                    this.container = d3.select(overlayPane)
                        .append('svg')
                        .attr("id", "hex-svg")
                        .attr('class', 'leaflet-layer leaflet-zoom-hide');
                }
                map.on({
                    'moveend': this.update
                }, this);
                this.update();
            }
        });

        L.hexbinLayer = function (data, styleFunction) {
            return new L.HexbinLayer(data, styleFunction);
        };

        L.mapbox.accessToken = 'pk.eyJ1IjoidXJiYW5pbnN0aXR1dGUiLCJhIjoiTEJUbmNDcyJ9.mbuZTy4hI_PWXw3C3UFbDQ';
        var cscale = d3.scale.linear().domain([0,1]).range(["#00FF00","#FFA500"]);
        var map = L.mapbox.map('map', 'urbaninstitute.iji12b2j', {
                maxZoom: 17,
                minZoom: 7,
                fadeAnimation: false
            })
            .setView([38.910, -77.02], 12);

        map.attributionControl
            .addAttribution('<a href="http://www.urban.org/">&copy; Urban Institute</a>');


        // Create the hexbin layer and add it to the map
        var hexLayer = L.hexbinLayer(assault2000, {
            style: hexbinStyle,
        }).addTo(map);

        function hexbinStyle(hexagons) {
            hexagons
                .attr("stroke", "black")
                .attr("fill", function (d) {
                    var values = d.map(function (elem) {
                        return elem[2].group;
                    })
                    var avg = d3.mean(d, function (d) {
                        return +d[2].group;
                    })
                    return cscale(avg);
                });
        }
    </script>
</body>

</html>